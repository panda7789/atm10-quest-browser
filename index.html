<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ATM10 Quest Browser</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,300;1,8..60,400&display=swap" rel="stylesheet">
<style>
/* â”€â”€â”€ VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root {
  --bg:        #1a1f2e;
  --bg2:       #212638;
  --bg3:       #2a3048;
  --bg4:       #323858;
  --border:    #323a52;
  --border2:   #3e4868;
  --gold:      #d4a843;
  --gold2:     #ecc96a;
  --gold-dim:  #9a7a38;
  --gold-glow: rgba(212,168,67,0.14);
  --text:      #d8d0bc;
  --text-dim:  #8c8070;
  --text-bright: #f0e8d0;
  --sidebar: 300px;
  --header: 52px;
}

/* â”€â”€â”€ RESET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Source Serif 4', Georgia, serif;
  background: var(--bg);
  color: var(--text);
  height: 100dvh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* â”€â”€â”€ HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header {
  height: var(--header);
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 0 18px;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 10;
}

.logo {
  font-family: 'Cinzel', serif;
  font-size: 1rem;
  font-weight: 700;
  color: var(--gold);
  letter-spacing: 0.1em;
  white-space: nowrap;
  text-shadow: 0 0 24px rgba(212,168,67,0.4);
}

.header-sep {
  width: 1px;
  height: 22px;
  background: var(--border2);
  flex-shrink: 0;
}

#chapterTitle {
  font-family: 'Cinzel', serif;
  font-size: 0.8rem;
  color: var(--text);
  letter-spacing: 0.08em;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.search-wrap {
  position: relative;
  flex-shrink: 0;
}
.search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text);
  font-size: 0.8rem;
  pointer-events: none;
}
#searchInput {
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-radius: 5px;
  padding: 6px 10px 6px 28px;
  color: var(--text-bright);
  font-family: 'Source Serif 4', serif;
  font-size: 0.85rem;
  width: 200px;
  outline: none;
  transition: border-color 0.2s, width 0.2s;
}
#searchInput:focus { border-color: var(--gold); width: 260px; }
#searchInput::placeholder { color: var(--text-dim); }

/* â”€â”€â”€ LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.layout {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* â”€â”€â”€ SIDEBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar {
  width: var(--sidebar);
  flex-shrink: 0;
  background: var(--bg2);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.sidebar-inner {
  overflow-y: auto;
  flex: 1;
  padding: 6px 0 12px;
}
.sidebar-inner::-webkit-scrollbar { width: 3px; }
.sidebar-inner::-webkit-scrollbar-track { background: transparent; }
.sidebar-inner::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

/* Group headers */
.group-header {
  padding: 16px 14px 6px;
  font-family: 'Cinzel', serif;
  font-size: 0.6rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--gold-dim);
  border-top: 1px solid var(--border);
  margin-top: 8px;
}
.group-header:first-child { margin-top: 0; border-top: none; padding-top: 10px; }

/* Chapter buttons */
.chapter-btn {
  display: flex;
  align-items: center;
  gap: 9px;
  width: 100%;
  padding: 7px 14px;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text);
  font-size: 0.82rem;
  font-family: 'Source Serif 4', serif;
  text-align: left;
  border-left: 2px solid transparent;
  transition: color 0.15s, background 0.15s, border-color 0.15s;
}
.chapter-btn:hover { color: var(--text-bright); background: rgba(255,255,255,0.04); }
.chapter-btn.active {
  color: var(--gold2);
  border-left-color: var(--gold);
  background: var(--gold-glow);
}
.chapter-btn .ch-count {
  margin-left: auto;
  font-size: 0.7rem;
  color: var(--text-dim);
  flex-shrink: 0;
}
.chapter-btn .ch-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }

/* â”€â”€â”€ MAP AREA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.map-area {
  flex: 1;
  overflow: hidden;
  position: relative;
  background: var(--bg);
  background-image:
    radial-gradient(circle at 20% 80%, rgba(212,168,67,0.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(74,120,191,0.03) 0%, transparent 50%);
}

/* Canvas */
#mapCanvas {
  display: block;
  width: 100%;
  height: 100%;
  cursor: grab;
}
#mapCanvas.grabbing { cursor: grabbing; }
#mapCanvas.hovering { cursor: pointer; }

/* Map controls */
.map-controls {
  position: absolute;
  bottom: 16px;
  right: 16px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.map-btn {
  width: 30px; height: 30px;
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-radius: 4px;
  color: var(--text-dim);
  font-size: 1rem;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: color 0.15s, border-color 0.15s;
}
.map-btn:hover { color: var(--text); border-color: var(--gold-dim); }

/* Empty state */
.empty-state {
  position: absolute; inset: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 10px; color: var(--text-dim);
  pointer-events: none;
}
.empty-state .big { font-size: 3rem; opacity: 0.2; }
.empty-state p { font-style: italic; font-size: 0.95rem; opacity: 0.5; }

/* â”€â”€â”€ QUEST POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#popupBackdrop {
  position: absolute; inset: 0;
  z-index: 40;
  display: none;
}
#popupBackdrop.open { display: block; }

#questPopup {
  position: absolute;
  z-index: 41;
  width: 460px;
  max-width: calc(100vw - 340px);
  max-height: calc(100vh - 80px);
  background: var(--bg2);
  border: 1px solid var(--border2);
  border-radius: 8px;
  box-shadow: 0 8px 40px rgba(0,0,0,0.7), 0 0 0 1px rgba(212,168,67,0.08);
  display: none;
  flex-direction: column;
  overflow: hidden;
  animation: popupIn 0.15s cubic-bezier(0.2,0,0,1);
}
#questPopup.open { display: flex; }
@keyframes popupIn {
  from { opacity: 0; transform: scale(0.96) translateY(6px); }
  to   { opacity: 1; transform: none; }
}

.popup-header {
  padding: 16px 40px 12px 18px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  position: relative;
}
.popup-close {
  position: absolute;
  top: 10px; right: 10px;
  background: none; border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 1rem; padding: 4px 6px;
  border-radius: 3px;
  line-height: 1;
  transition: color 0.15s, background 0.15s;
}
.popup-close:hover { color: var(--text); background: rgba(255,255,255,0.06); }

.popup-title {
  font-family: 'Cinzel', serif;
  font-size: 1rem;
  color: var(--gold2);
  line-height: 1.35;
}
.popup-subtitle {
  font-style: italic;
  font-size: 0.82rem;
  color: var(--text);
  margin-top: 3px;
}

.popup-body {
  overflow-y: auto;
  flex: 1;
  padding: 16px 18px 20px;
  min-height: 0;
}
.popup-body::-webkit-scrollbar { width: 3px; }
.popup-body::-webkit-scrollbar-track { background: transparent; }
.popup-body::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }

/* Section label */
.section-label {
  font-family: 'Cinzel', serif;
  font-size: 0.6rem;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-bottom: 8px;
}

/* Description */
.quest-desc {
  font-size: 0.88rem;
  line-height: 1.75;
  color: var(--text-bright);
  word-break: break-word;
}

.popup-divider {
  height: 1px;
  background: var(--border);
  margin: 14px 0;
}

/* Tasks */
.task-list { display: flex; flex-direction: column; gap: 4px; }
.task-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-radius: 5px;
  font-size: 0.82rem;
  color: var(--text);
}
.task-item .t-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.task-item .t-count { font-size: 0.74rem; color: var(--gold2); flex-shrink: 0; }

/* Item stats badges */
.task-item-wrap { display: flex; flex-direction: column; gap: 3px; }
.item-stats { display: flex; flex-wrap: wrap; gap: 4px; padding: 0 10px 5px 38px; }

/* Smart filter grid */
.filter-items-grid {
  display: flex; flex-wrap: wrap; gap: 3px;
  padding: 4px 10px 6px 38px;
}
.filter-icon { display: inline-flex; cursor: default; }

/* Rewards */
.rewards-list { display: flex; flex-direction: column; gap: 3px; }
.reward-item {
  display: flex; align-items: center; gap: 8px;
  padding: 4px 10px;
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-left: 2px solid rgba(255,200,60,0.5);
  border-radius: 5px;
  font-size: 0.82rem; color: var(--text);
}
.reward-item .r-name { flex: 1; }
.reward-xp-icon { width: 20px; text-align: center; flex-shrink: 0; }

/* Wiki link */
.popup-wiki {
  position: absolute; top: 10px; right: 40px;
  font-size: 1rem; text-decoration: none; opacity: 0.6;
  transition: opacity 0.15s;
}
.popup-wiki:hover { opacity: 1; }
.stat-badge {
  display: inline-flex; align-items: center; gap: 3px;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 4px; padding: 1px 6px;
  font-size: 0.70rem; color: var(--text);
}
.stat-badge.dmg  { border-color: rgba(220,80,80,0.5);  color: #f0a0a0; }
.stat-badge.arm  { border-color: rgba(80,140,220,0.5); color: #90c0f0; }
.stat-badge.spd  { border-color: rgba(80,200,130,0.5); color: #90d8b0; }
.stat-badge.spec { border-color: rgba(200,160,60,0.5); color: #e0c070; }

/* No desc */
.no-desc { font-style: italic; font-size: 0.85rem; color: var(--text-dim); }

/* â”€â”€â”€ MINECRAFT TEXT COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.mc-0 { color: #111; }
.mc-1 { color: #0000aa; }
.mc-2 { color: #59a05a; }
.mc-3 { color: #55bfc8; }
.mc-4 { color: #c44; }
.mc-5 { color: #c45ab5; }
.mc-6 { color: var(--gold); }
.mc-7 { color: #aaa; }
.mc-8 { color: #666; }
.mc-9 { color: #6699ff; }
.mc-a { color: #7ec87e; }
.mc-b { color: #7ff5ff; }
.mc-c { color: #ff6060; }
.mc-d { color: #ff70ff; }
.mc-e { color: #ffee77; }
.mc-f { color: #f0e8d8; }
.mc-bold { font-weight: 700; color: var(--text-bright); }
.mc-italic { font-style: italic; }
.mc-underline { text-decoration: underline; }
.mc-strike { text-decoration: line-through; }

/* â”€â”€â”€ TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#tooltip {
  position: fixed;
  background: var(--bg3);
  border: 1px solid var(--border2);
  border-radius: 5px;
  padding: 6px 10px;
  font-size: 0.78rem;
  color: var(--text);
  pointer-events: none;
  z-index: 100;
  max-width: 220px;
  display: none;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}
#tooltip .tt-title { color: var(--gold2); font-family: 'Cinzel', serif; font-size: 0.72rem; margin-bottom: 2px; }
#tooltip .tt-sub { color: var(--text); font-style: italic; }

/* â”€â”€â”€ MOBILE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar-toggle {
  display: none;
  background: none;
  border: none;
  color: var(--text);
  font-size: 1.2rem;
  cursor: pointer;
  padding: 4px 6px;
  flex-shrink: 0;
  line-height: 1;
}

@media (max-width: 700px) {
  :root { --sidebar: 280px; }

  .sidebar-toggle { display: flex; align-items: center; }
  .header-sep { display: none; }
  #chapterTitle { font-size: 0.72rem; }
  #searchInput { width: 140px; }
  #searchInput:focus { width: 170px; }

  /* Sidebar jako overlay drawer */
  .sidebar {
    position: fixed;
    top: 0; left: 0; bottom: 0;
    z-index: 80;
    transform: translateX(-100%);
    transition: transform 0.25s cubic-bezier(0.4,0,0.2,1);
    box-shadow: 4px 0 24px rgba(0,0,0,0.6);
  }
  .sidebar.mobile-open { transform: translateX(0); }

  /* Backdrop za sidebarom */
  #sidebarBackdrop {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 79;
  }
  #sidebarBackdrop.open { display: block; }

  /* Quest popup â€” fullscreen na mobilu */
  #questPopup {
    position: fixed !important;
    inset: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
    border-radius: 0 !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 90;
  }

  /* Map controls â€” menÅ¡Ã­ a vÃ½Å¡ kvÅ¯li popup */
  .map-controls { bottom: 12px; right: 12px; }
  .map-btn { width: 36px; height: 36px; font-size: 1.1rem; }

  /* Tooltip skryjeme na mobilu (tap otevÅ™e rovnou popup) */
  #tooltip { display: none !important; }
}

#loadingOverlay {
  position: fixed; inset: 0;
  background: var(--bg);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 16px; z-index: 200;
}
.spinner {
  width: 40px; height: 40px;
  border: 3px solid var(--border2);
  border-top-color: var(--gold);
  border-radius: 50%;
  animation: spin 0.7s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-text { font-family: 'Cinzel', serif; font-size: 0.8rem; color: var(--text); letter-spacing: 0.1em; }

/* â”€â”€â”€ SEARCH OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#searchOverlay {
  position: absolute;
  inset: 0;
  background: rgba(20,24,36,0.97);
  z-index: 50;
  display: none;
  overflow-y: auto;
  padding: 20px;
}
#searchOverlay.visible { display: block; }
.search-results-title {
  font-family: 'Cinzel', serif;
  font-size: 0.7rem;
  letter-spacing: 0.15em;
  color: var(--text);
  margin-bottom: 12px;
}
.search-group-title {
  font-size: 0.75rem;
  color: var(--gold2);
  font-family: 'Cinzel', serif;
  letter-spacing: 0.06em;
  margin: 14px 0 6px;
  padding-bottom: 4px;
  border-bottom: 1px solid var(--border2);
}
.search-result-item {
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  margin-bottom: 2px;
  transition: background 0.1s;
}
.search-result-item:hover { background: var(--bg3); }
.sri-title { font-size: 0.88rem; color: var(--text-bright); }
.sri-desc { font-size: 0.77rem; color: var(--text); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
mark { background: rgba(212,168,67,0.3); color: var(--gold2); border-radius: 2px; padding: 0 1px; }
/* Sidebar tabs */
.sidebar-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.stab {
  flex: 1; padding: 9px 0;
  background: none; border: none;
  color: var(--text-dim); font-size: 0.82rem;
  cursor: pointer; transition: color 0.15s;
  border-bottom: 2px solid transparent;
  margin-bottom: -1px;
}
.stab:hover { color: var(--text); }
.stab.active { color: var(--gold2); border-bottom-color: var(--gold2); }

/* Mod cards */
.mod-card {
  display: flex; align-items: center; gap: 9px;
  padding: 7px 12px;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.1s;
  margin-bottom: 1px;
}
.mod-card:hover { background: rgba(255,255,255,0.04); }
.mod-card.active { background: rgba(212,168,67,0.08); }
.mod-card-info { flex: 1; min-width: 0; }
.mod-card-name { font-size: 0.84rem; color: var(--text-bright); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.mod-card-sub  { font-size: 0.72rem; color: var(--text); margin-top: 1px; }
.mod-card-count { font-size: 0.72rem; color: var(--gold2); flex-shrink: 0; }

/* Mod detail (v mapArea) */
#modView {
  display: none;
  flex-direction: column;
  height: 100%;
  overflow-y: auto;
  padding: 20px;
  box-sizing: border-box;
}
#modView::-webkit-scrollbar { width: 4px; }
#modView::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 2px; }
.mod-view-header {
  display: flex; align-items: center; gap: 12px;
  margin-bottom: 20px;
}
.mod-view-title { font-size: 1.2rem; color: var(--text-bright); }
.mod-view-meta  { font-size: 0.8rem; color: var(--text); margin-top: 2px; }
.mod-chapter-section { margin-bottom: 24px; }
.mod-chapter-title {
  font-size: 0.78rem; color: var(--gold2);
  text-transform: uppercase; letter-spacing: 0.06em;
  margin-bottom: 8px; padding-bottom: 4px;
  border-bottom: 1px solid var(--border);
}
.mod-quest-list { display: flex; flex-direction: column; gap: 4px; }
.mod-quest-item {
  display: flex; align-items: center; gap: 8px;
  padding: 6px 10px;
  background: var(--bg2); border: 1px solid var(--border);
  border-radius: 5px; cursor: pointer;
  transition: border-color 0.1s, background 0.1s;
  font-size: 0.82rem; color: var(--text);
}
.mod-quest-item:hover { background: var(--bg4); border-color: var(--border2); color: var(--text-bright); }
</style>
</head>
<body>

<!-- Loading -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <div class="loading-text">Loading quest dataâ€¦</div>
</div>

<!-- Header -->
<header>
  <button class="sidebar-toggle" id="sidebarToggle" title="Chapters">â˜°</button>
  <div class="logo">âš” ATM10</div>
  <div class="header-sep"></div>
  <div id="chapterTitle">Select a chapter</div>
  <div class="search-wrap">
    <span class="search-icon">ğŸ”</span>
    <input id="searchInput" type="text" placeholder="Search questsâ€¦" autocomplete="off">
  </div>
</header>

<!-- Sidebar backdrop (mobile) -->
<div id="sidebarBackdrop"></div>

<!-- Layout -->
<div class="layout">

  <!-- Sidebar -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-tabs">
      <button class="stab active" id="stabChapters" onclick="switchSidebarTab('chapters')">Chapters</button>
      <button class="stab" id="stabMods" onclick="switchSidebarTab('mods')">Mods</button>
    </div>
    <div class="sidebar-inner" id="sidebarInner"></div>
  </div>

  <!-- Map -->
  <div class="map-area" id="mapArea">
    <canvas id="mapCanvas"></canvas>
    <div class="empty-state" id="emptyState">
      <div class="big">ğŸ“œ</div>
      <p>Choose a chapter from the sidebar</p>
    </div>

    <!-- Mod detail view -->
    <div id="modView"></div>
    <div class="map-controls">
      <button class="map-btn" id="btnZoomIn" title="Zoom in">+</button>
      <button class="map-btn" id="btnZoomOut" title="Zoom out">âˆ’</button>
      <button class="map-btn" id="btnFit" title="Fit to screen">âŠ¡</button>
      <button class="map-btn" id="btnDeps" title="Toggle dependency lines" style="font-size:0.7rem;letter-spacing:-0.02em;">DEP</button>
    </div>

    <!-- Quest popup -->
    <div id="popupBackdrop"></div>
    <div id="questPopup">
      <div class="popup-header" id="popupHeader">
        <button class="popup-close" id="popupClose">âœ•</button>
      </div>
      <div class="popup-body" id="popupBody"></div>
    </div>

    <!-- Search overlay -->
    <div id="searchOverlay"></div>
  </div>

</div>

<!-- Tooltip -->
<div id="tooltip"></div>

<script>
'use strict';
// â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SloÅ¾ka s dynamickÃ½mi daty (quests.json, icons/, manifesty).
// LokÃ¡lnÄ›: '' (vedle index.html)
// Docker s volume: 'data/'
const DATA_PATH = 'data/';

// â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let DATA = null;                 // loaded JSON
let activeChapter = null;        // chapter object
let selectedQuestId = null;      // string id

// Map viewport
let vpX = 0, vpY = 0, vpScale = 60;  // px per grid unit
const MIN_SCALE = 15, MAX_SCALE = 140;

// Deps display mode: 'all' | 'hover' | 'none'
let depsMode = 'hover';  // default â€” mÃ©nÄ› nepÅ™ehlednÃ©

// Drag state
let isDragging = false, dragStartX = 0, dragStartY = 0, vpXStart = 0, vpYStart = 0;
let hoveredQuestId = null;

// Canvas
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

// â”€â”€â”€ MINECRAFT COLOR RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MC_COLOR_MAP = {
  '0':'#111','1':'#0055bb','2':'#59a05a','3':'#55bfc8',
  '4':'#cc4444','5':'#c45ab5','6':'#d4a843','7':'#aaaaaa',
  '8':'#555555','9':'#6699ff','a':'#7ec87e','b':'#7ff5ff',
  'c':'#ff6060','d':'#ff70ff','e':'#ffee77','f':'#ede0c4'
};

function mcToHtml(text) {
  if (!text) return '';

  // RozdÄ›l text na ÄÃ¡sti: {image:...} tagy a zbytek
  // Zpracuj je oddÄ›lenÄ› aby escHtml nezniÄil <img> tagy
  const segments = [];
  let last = 0;
  const imgRe = /\{image:([^\s}]+)([^}]*)\}/g;
  let m;
  while ((m = imgRe.exec(text)) !== null) {
    if (m.index > last) segments.push({ type: 'text', val: text.slice(last, m.index) });
    const url = resolveImageUrl(m[1]);
    if (url) {
      const wm = m[2].match(/width:(\d+)/);
      const hm = m[2].match(/height:(\d+)/);
      const am = m[2].match(/align:(\w+)/);
      const w  = wm ? `width:${wm[1]}px;max-width:100%;` : 'max-width:100%;';
      const h  = hm ? `height:${hm[1]}px;` : '';
      const bl = am && am[1] === 'center' ? 'display:block;margin:6px auto;' : 'display:inline-block;margin:4px 0;';
      segments.push({ type: 'html', val: `<img src="${url}" style="${bl}${w}${h}image-rendering:pixelated;" alt="">` });
    }
    last = m.index + m[0].length;
  }
  if (last < text.length) segments.push({ type: 'text', val: text.slice(last) });

  return segments.map(seg => {
    if (seg.type === 'html') return seg.val;
    // Zpracuj Minecraft color kÃ³dy
    const parts = seg.val.split(/&(?=[0-9a-fA-Flonmr])/);
    let html = escHtml(parts[0]);
    for (let i = 1; i < parts.length; i++) {
      const code = parts[i][0].toLowerCase();
      const rest = parts[i].slice(1);
      if      (code === 'r') html += escHtml(rest);
      else if (code === 'l') html += `<span class="mc-bold">${escHtml(rest)}</span>`;
      else if (code === 'o') html += `<span class="mc-italic">${escHtml(rest)}</span>`;
      else if (code === 'n') html += `<span class="mc-underline">${escHtml(rest)}</span>`;
      else if (code === 'm') html += `<span class="mc-strike">${escHtml(rest)}</span>`;
      else if (MC_COLOR_MAP[code]) html += `<span class="mc-${code}">${escHtml(rest)}</span>`;
      else html += escHtml(parts[i]);
    }
    return html;
  }).join('');
}

function stripMc(text) {
  return text ? text.replace(/&[0-9a-fA-Flonmr]/g, '') : '';
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// â”€â”€â”€ ICONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Dva mÃ³dy:
//   ATLAS  â€” jeden velkÃ½ icons_atlas.png + icons_atlas.json (pro hosting)
//   FILES  â€” individuÃ¡lnÃ­ soubory icons/namespace/item.png  (po extract_icons.js)
let ICON_MODE  = null;
let ATLAS_META = null;
let FILES_MAP  = null;
let ADV_MAP    = null;
let ITEM_DATA  = null;   // itemId â†’ { category, damage, armor, ... }

async function loadIcons() {
  try {
    const res = await fetch(DATA_PATH + 'icons_atlas.json');
    if (res.ok) {
      ATLAS_META = await res.json();
      ICON_MODE = 'atlas';
      console.log(`Icons: atlas mode (${Object.keys(ATLAS_META.icons).length} ikon)`);
    }
  } catch {}

  try {
    const res = await fetch(DATA_PATH + 'icons_manifest.json');
    if (res.ok) {
      FILES_MAP = await res.json();
      if (!ICON_MODE) ICON_MODE = 'files';
      console.log(`Icons: files manifest (${Object.keys(FILES_MAP).length} klÃ­ÄÅ¯)`);
    }
  } catch {}

  try {
    let res = await fetch(DATA_PATH + 'chapter_images_manifest.json');
    if (!res.ok) res = await fetch(DATA_PATH + 'icons_manifest.json');
    if (res.ok && !FILES_MAP) FILES_MAP = await res.json();
    else if (res.ok) Object.assign(FILES_MAP, await res.json());
  } catch {}

  // Advancement â†’ item mapa
  try {
    const res = await fetch(DATA_PATH + 'advancements_manifest.json');
    if (res.ok) {
      ADV_MAP = await res.json();
      console.log(`Advancements manifest: ${Object.keys(ADV_MAP).length} zÃ¡znamÅ¯`);
    }
  } catch {}

  // Item data (statistiky zbranÃ­, brnÄ›nÃ­, nÃ¡strojÅ¯)
  try {
    const res = await fetch(DATA_PATH + 'item_data.json');
    if (res.ok) {
      ITEM_DATA = await res.json();
      console.log(`Item data: ${Object.keys(ITEM_DATA).length} itemÅ¯`);
    }
  } catch {}

  iconCache.clear();
  imageCache.clear();
}

function itemIcon(itemId, fallbackEmoji, size = 20) {
  if (!itemId) return `<span>${fallbackEmoji || ''}</span>`;
  const TILE = size;

  if (ICON_MODE === 'atlas') {
    const entry = ATLAS_META.icons[itemId]
      || ATLAS_META.icons[`${itemId}_item`]
      || null;
    if (entry) {
      const srcTile = ATLAS_META.tile;
      const scale   = TILE / srcTile;
      const bgW     = ATLAS_META.width  * scale;
      const bgH     = ATLAS_META.height * scale;
      const bgX     = -(entry.x * scale);
      const bgY     = -(entry.y * scale);
      return `<span style="display:inline-block;width:${TILE}px;height:${TILE}px;flex-shrink:0;image-rendering:pixelated;background:url('${DATA_PATH}icons_atlas.webp') ${bgX}px ${bgY}px / ${bgW}px ${bgH}px no-repeat;" title="${escHtml(itemId)}"></span>`;
    }
  }

  if (FILES_MAP) {
    const url = FILES_MAP[itemId] || FILES_MAP[`${itemId}_item`] || null;
    if (url) {
      return `<img src="${escHtml(url)}" alt="${escHtml(itemId)}" title="${escHtml(itemId)}" style="width:${TILE}px;height:${TILE}px;image-rendering:pixelated;vertical-align:middle;flex-shrink:0;" onerror="this.replaceWith(document.createTextNode('${fallbackEmoji}'))">`;
    }
  }

  return `<span title="${escHtml(itemId)}">${fallbackEmoji}</span>`;
}

// â”€â”€â”€ CANVAS ICON CACHE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PÅ™edloadovanÃ© Image objekty pro kreslenÃ­ na canvas
const iconCache = new Map();  // itemId â†’ HTMLImageElement | 'loading' | 'error'

function lookupIconId(itemId) {
  const colon = itemId.indexOf(':');
  if (colon === -1) return [itemId];
  const ns   = itemId.slice(0, colon);
  const name = itemId.slice(colon + 1);
  return [
    itemId,
    `${ns}:${name}_item`,
    `${ns}:${name}_block`,
  ];
}

// VrÃ¡tÃ­ true pokud URL textury pochÃ¡zÃ­ z textures/block/
function isBlockTexture(itemId) {
  if (!FILES_MAP) return false;
  const variants = lookupIconId(itemId);
  for (const v of variants) {
    const url = FILES_MAP[v];
    if (url) return url.includes('/block/');
  }
  return false;
}

// VrÃ¡tÃ­ true pokud je textura entity sprite sheet
function isEntityTexture(itemId) {
  if (!FILES_MAP) return false;
  const variants = lookupIconId(itemId);
  for (const v of variants) {
    const url = FILES_MAP[v];
    if (url) return url.includes('/entity/');
  }
  return false;
}

// NakreslÃ­ izometrickou 3D kostku z jednÃ© textury. StÅ™ed na (0,0).
function drawIsoCube(ctx, imgTop, imgSide, imgFront, size) {
  const w = size * 0.5;
  const h = w * 0.5;
  const d = w * 0.7;

  const top  = [0,  -(h + d)];
  const lt   = [-w, -d      ];
  const rt   = [ w, -d      ];
  const mid  = [0,  -(d - h)];
  const lb   = [-w,  h      ];
  const rb   = [ w,  h      ];
  const bot  = [0,   2 * h  ];

  function drawFace(img, p0, p1, p2, p3, brightness) {
    if (!img) return;
    const T = img.naturalWidth || 16;
    const ax = (p1[0]-p0[0])/T, ay = (p1[1]-p0[1])/T;
    const bx = (p3[0]-p0[0])/T, by = (p3[1]-p0[1])/T;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(p0[0],p0[1]); ctx.lineTo(p1[0],p1[1]);
    ctx.lineTo(p2[0],p2[1]); ctx.lineTo(p3[0],p3[1]);
    ctx.closePath();
    ctx.clip();
    ctx.transform(ax, ay, bx, by, p0[0], p0[1]);
    ctx.drawImage(img, 0, 0, T, T);
    if (brightness < 1) {
      ctx.fillStyle = `rgba(0,0,0,${(1-brightness).toFixed(2)})`;
      ctx.fillRect(0, 0, T, T);
    }
    ctx.restore();
  }

  const cy = (top[1] + bot[1]) / 2;
  ctx.save();
  ctx.translate(0, -cy);
  drawFace(imgTop,   lt,  top, rt,  mid, 1.0);
  drawFace(imgFront, lt,  mid, bot, lb,  0.65);
  drawFace(imgSide,  mid, rt,  rb,  bot, 0.80);
  ctx.restore();
}

function getCanvasIcon(itemId) {
  if (!itemId || !ICON_MODE) return null;
  if (iconCache.has(itemId)) {
    const v = iconCache.get(itemId);
    return (v instanceof HTMLImageElement && v.complete && v.naturalWidth > 0) ? v : null;
  }

  let url = null;

  if (ICON_MODE === 'atlas') {
    const variants = lookupIconId(itemId);
    let entry = null;
    for (const v of variants) {
      entry = ATLAS_META.icons[v];
      if (entry) break;
    }
    if (entry) {
      if (!getCanvasIcon._atlasImg) {
        const img = new Image();
        img.src = DATA_PATH + 'icons_atlas.webp';
        img.onerror = () => { img.src = DATA_PATH + 'icons_atlas.png'; };
        getCanvasIcon._atlasImg = img;
      }
      const atlasImg = getCanvasIcon._atlasImg;
      if (!atlasImg.complete || atlasImg.naturalWidth === 0) {
        if (!getCanvasIcon._atlasListening) {
          getCanvasIcon._atlasListening = true;
          atlasImg.addEventListener('load', () => { iconCache.clear(); requestDraw(); });
        }
        iconCache.set(itemId, 'loading');
        return null;
      }
      const TILE = ATLAS_META.tile;
      const oc = document.createElement('canvas');
      oc.width = oc.height = TILE;
      oc.getContext('2d').drawImage(atlasImg, entry.x, entry.y, TILE, TILE, 0, 0, TILE, TILE);
      const img = new Image();
      img.src = oc.toDataURL();
      iconCache.set(itemId, img);
      return img.complete ? img : null;
    }
    // NenÃ­ v atlasu â€” padni pÅ™es na FILES_MAP
  }

  if (FILES_MAP) {
    const variants = lookupIconId(itemId);
    for (const v of variants) {
      if (FILES_MAP[v]) { url = FILES_MAP[v]; break; }
    }
    if (!url) { iconCache.set(itemId, 'error'); return null; }
    const img = new Image();
    iconCache.set(itemId, img);
    img.onload = () => requestDraw();
    img.onerror = () => iconCache.set(itemId, 'error');
    img.src = url;
    if (img.complete && img.naturalWidth > 0) return img;
    return null;
  }

  return null;
}

// â”€â”€â”€ ANIMACE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GlobÃ¡lnÃ­ Äas pro animace (sekundy) â€” aktualizuje se v draw loop
let animTime = 0;
let lastFrameTime = performance.now();

function getAnimFrame(items, intervalMs = 1000) {
  if (!items || items.length === 0) return null;
  const idx = Math.floor(animTime * 1000 / intervalMs) % items.length;
  return items[idx];
}

// VrÃ¡tÃ­ HTML se statistikami itemu nebo '' pokud Å¾Ã¡dnÃ© nejsou
function renderItemStats(itemId) {
  if (!ITEM_DATA || !itemId) return '';
  const d = ITEM_DATA[itemId];
  if (!d) return '';

  const badges = [];

  // Kategorie ikona
  const catIcon = {
    sword: 'âš”ï¸', axe: 'ğŸª“', bow: 'ğŸ¹', crossbow: 'ğŸ¹', trident: 'ğŸ”±',
    pickaxe: 'â›ï¸', shovel: 'ğŸªš', hoe: 'ğŸŒ¾', tool: 'ğŸ”§',
    helmet: 'ğŸª–', chestplate: 'ğŸ¥‹', leggings: 'ğŸ‘–', boots: 'ğŸ‘¢',
    armor: 'ğŸ›¡ï¸', shield: 'ğŸ›¡ï¸', weapon: 'âš”ï¸',
  }[d.category] || '';

  // Damage
  if (d.damage) {
    const dmg = Math.round(d.damage * 10) / 10;
    badges.push(`<span class="stat-badge dmg">âš”ï¸ ${dmg} dmg</span>`);
  }
  // Attack speed (vanilla = 4.0, zobraz jen pokud je jinÃ½)
  if (d.attack_speed !== undefined) {
    const spd = Math.round(d.attack_speed * 10) / 10;
    badges.push(`<span class="stat-badge spd">âš¡ ${spd}/s</span>`);
  }
  // Armor
  if (d.armor) {
    const arm = Math.round(d.armor * 10) / 10;
    badges.push(`<span class="stat-badge arm">ğŸ›¡ï¸ ${arm} armor</span>`);
  }
  // Toughness
  if (d.toughness) {
    const t = Math.round(d.toughness * 10) / 10;
    badges.push(`<span class="stat-badge arm">ğŸ’ ${t} tough</span>`);
  }
  // Max health bonus
  if (d.max_health) {
    const h = Math.round(d.max_health * 10) / 10;
    badges.push(`<span class="stat-badge spec">â¤ï¸ +${h} hp</span>`);
  }
  // Knockback resistance
  if (d.knockback_res) {
    const k = Math.round(d.knockback_res * 100);
    badges.push(`<span class="stat-badge spec">ğŸ—¿ ${k}% kb res</span>`);
  }
  // Crit chance / damage
  if (d.crit_chance) badges.push(`<span class="stat-badge spec">ğŸ¯ ${Math.round(d.crit_chance*100)}% crit</span>`);
  if (d.crit_damage) badges.push(`<span class="stat-badge dmg">ğŸ’¥ ${Math.round(d.crit_damage*100)}% crit dmg</span>`);

  if (badges.length === 0) return '';
  return `<div class="item-stats">${badges.join('')}</div>`;
}

// Mapa namespace â†’ wiki URL
const WIKI_URLS = {
  'minecraft':            'https://minecraft.wiki/w/',
  'create':               'https://create.fandom.com/wiki/',
  'mekanism':             'https://wiki.mekanism.com/wiki/',
  'ae2':                  'https://ae2.ae-mod.info/',
  'appliedenergistics2':  'https://ae2.ae-mod.info/',
  'thermal':              'https://teamcofh.com/docs/',
  'immersiveengineering': 'https://ftb.fandom.com/wiki/Immersive_Engineering',
  'ars_nouveau':          'https://www.arsnouveau.wiki/',
  'occultism':            'https://klikli-dev.github.io/occultism/',
  'pneumaticcraft':       'https://pneumaticcraft.com/wiki/',
  'refinedStorage':       'https://refinedmods.com/refined-storage/',
  'refinedstorage':       'https://refinedmods.com/refined-storage/',
  'powah':                'https://ftb.fandom.com/wiki/Powah',
  'tconstruct':           'https://tinkers-construct.fandom.com/wiki/',
  'apotheosis':           'https://ftb.fandom.com/wiki/Apotheosis',
  'botania':              'https://botaniamod.net/changelog.shtml',
  'twilightforest':       'https://ftb.fandom.com/wiki/Twilight_Forest',
  'undergarden':          'https://ftb.fandom.com/wiki/The_Undergarden',
  'iceandfire':           'https://ice-and-fire-mod.fandom.com/wiki/',
};

function getWikiUrl(q) {
  // Zkus z ikony / prvnÃ­ho tasku zjistit namespace
  const info = getQuestIconId(q);
  const id = info?.id || q.tasks?.[0]?.item || q.tasks?.[0]?.entity;
  if (!id) return null;
  const ns = id.split(':')[0];
  const name = id.split(':')[1];
  const base = WIKI_URLS[ns];
  if (!base) return null;
  if (ns === 'minecraft') {
    return base + name.split('_').map(w => w[0].toUpperCase() + w.slice(1)).join('_');
  }
  return base;
}

function getQuestIconId(q) {
  if (q.icon) return { id: q.icon };
  const tasks = q.tasks;
  if (!tasks || tasks.length === 0) return null;
  const first = tasks[0];
  if (first.item === 'ftbfiltersystem:smart_filter' && first.filter_items?.length) {
    return { id: getAnimFrame(first.filter_items) };
  }
  if (first.type === 'kill' && first.entity) {
    // Zkus spawn egg nejdÅ™Ã­v, pak fallback na entity texturu
    const [ns, name] = first.entity.split(':');
    const egg = `${ns}:${name}_spawn_egg`;
    if (FILES_MAP?.[egg] || ATLAS_META?.icons?.[egg]) return { id: egg };
    return { id: first.entity };
  }
  if (first.type === 'advancement' && first.advancement) {
    // NejdÅ™Ã­v zkus ADV_MAP (z advancement JSON display.icon)
    const itemId = ADV_MAP?.[first.advancement];
    if (itemId) return { id: itemId };
    // Fallback: poslednÃ­ ÄÃ¡st cesty jako item ID (napÅ™. "minecraft:end/dragon_egg" â†’ "minecraft:dragon_egg")
    const parts = first.advancement.split(':');
    if (parts.length === 2) {
      const name = parts[1].split('/').pop(); // "dragon_egg"
      const fallbackId = `${parts[0]}:${name}`;
      return { id: fallbackId };
    }
    return null;
  }
  return { id: first.item || first.entity || null };
}

function drawQuestIcon(ctx, q, size) {
  const info = getQuestIconId(q);
  if (!info || !info.id) return false;

  ctx.save();
  ctx.imageSmoothingEnabled = false;

  if (isBlockTexture(info.id)) {
    const imgTop   = getCanvasIcon(info.id + '#top')   || getCanvasIcon(info.id);
    const imgSide  = getCanvasIcon(info.id + '#side')  || getCanvasIcon(info.id);
    const imgFront = getCanvasIcon(info.id + '#front') || getCanvasIcon(info.id);
    if (!imgTop && !imgSide && !imgFront) { ctx.restore(); return false; }
    drawIsoCube(ctx, imgTop, imgSide, imgFront, size * 0.72);
  } else if (isEntityTexture(info.id)) {
    const img = getCanvasIcon(info.id);
    if (!img) { ctx.restore(); return false; }
    const sw = img.naturalWidth, sh = img.naturalHeight;

    // Zkus GeckoLib UV metadata
    const uvRaw = FILES_MAP?.[info.id + '#head_uv'];
    if (uvRaw) {
      try {
        const uv = JSON.parse(uvRaw);
        // uv.u, uv.v = pixel offset na texture, uv.size = [w,h,d] nebo [w,h]
        const uw = (uv.size?.[0] ?? 8);
        const uh = (uv.size?.[1] ?? 8);
        const half = size / 2;
        ctx.drawImage(img, uv.u, uv.v, uw, uh, -half, -half, size, size);
        ctx.restore(); return true;
      } catch {}
    }

    // Fallback: Minecraft skin layout (hlava = 8,8 â†’ 16,16 z 64x64)
    // Pro non-humanoid mobs zkus prvnÃ­ osminu textury
    const ratio = sw / sh;
    let sx, sy, sSize;
    if (Math.abs(ratio - 1) < 0.1) {
      // ÄŒtvercovÃ¡ textura â€” pravdÄ›podobnÄ› jednoduchÃ½ mob, pouÅ¾ij celou
      sx = 0; sy = 0; sSize = sw;
    } else {
      // Minecraft skin 2:1 pomÄ›r â€” hlava v 8,8
      sx = sw * 8/64; sy = sh * 8/64; sSize = sw * 8/64;
    }
    const half = size / 2;
    ctx.drawImage(img, sx, sy, sSize, sSize, -half, -half, size, size);
  } else {
    const img = getCanvasIcon(info.id);
    if (!img) { ctx.restore(); return false; }
    const half = size / 2;
    ctx.drawImage(img, -half, -half, size, size);
  }

  ctx.restore();
  return true;
}



// â”€â”€â”€ CHAPTER IMAGES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resolveImageUrl(imageRef) {
  if (!imageRef || !FILES_MAP) return null;
  const colon = imageRef.indexOf(':');
  if (colon === -1) return null;
  const ns      = imageRef.slice(0, colon);
  const imgPath = imageRef.slice(colon + 1);

  // Zkus klÃ­Äe v poÅ™adÃ­ priority
  const basename = imgPath.split('/').pop().replace(/\.png$/, '');
  return FILES_MAP[imageRef]           // pÅ™esnÃ½ klÃ­Ä: "atm:textures/questpics/ae2.png"
      || FILES_MAP[`${ns}:${basename}`] // basename: "atm:ae2"
      || null;
}

const imageCache = new Map();

function getChapterImage(imageRef) {
  if (imageCache.has(imageRef)) {
    const v = imageCache.get(imageRef);
    return (v instanceof HTMLImageElement && v.complete && v.naturalWidth > 0) ? v : null;
  }
  if (!FILES_MAP) return null;  // jeÅ¡tÄ› se naÄÃ­tÃ¡ â€” nezacachuj nic
  const url = resolveImageUrl(imageRef);
  if (!url) { imageCache.set(imageRef, 'missing'); return null; }
  const img = new Image();
  img.src = url;
  img.onload = () => requestDraw();
  imageCache.set(imageRef, img);
  return null;
}

function drawChapterImages(ctx, chapter) {
  if (!chapter.images || !chapter.images.length) return;
  for (const imgDef of chapter.images) {
    const img = getChapterImage(imgDef.image);
    if (!img) continue;
    const [sx, sy] = worldToScreen(imgDef.x, imgDef.y);
    const sw = imgDef.w * vpScale;
    const sh = imgDef.h * vpScale;
    ctx.save();
    ctx.translate(sx, sy);
    if (imgDef.rotation) ctx.rotate(imgDef.rotation * Math.PI / 180);
    ctx.globalAlpha = 0.9;
    ctx.imageSmoothingEnabled = true;
    // x,y je stÅ™ed obrÃ¡zku (stejnÄ› jako FTB Quests)
    ctx.drawImage(img, -sw / 2, -sh / 2, sw, sh);
    ctx.restore();
  }
}

async function loadData() {
  try {
    const [questRes] = await Promise.all([
      fetch(DATA_PATH + 'quests.json'),
      loadIcons(),
    ]);
    if (!questRes.ok) throw new Error(`HTTP ${questRes.status}`);
    DATA = await questRes.json();
    document.getElementById('loadingOverlay').style.display = 'none';
    buildSidebar();
  } catch (e) {
    document.getElementById('loadingOverlay').innerHTML =
      `<div style="color:#ff6060;font-family:Cinzel,serif;font-size:0.9rem;max-width:320px;text-align:center;padding:20px;">
        <div style="font-size:2rem;margin-bottom:12px">âš ï¸</div>
        Cannot load <strong>quests.json</strong><br><br>
        <small style="opacity:0.6">Make sure quests.json is in the same folder as this HTML file,<br>then open via a local server or browser that allows local file access.</small><br><br>
        <small style="opacity:0.4">${escHtml(e.message)}</small>
      </div>`;
  }
}

// â”€â”€â”€ SIDEBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€ MOD INDEX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let MOD_INDEX = null;  // ns â†’ { name, quests: [{q, chapter}], topItem }

// HezkÃ© nÃ¡zvy pro znÃ¡mÃ© namespace
const MOD_NAMES = {
  ae2: 'Applied Energistics 2', ars_nouveau: 'Ars Nouveau',
  botania: 'Botania', cataclysm: 'Cataclysm',
  create: 'Create', draconicevolution: 'Draconic Evolution',
  evilcraft: 'EvilCraft', eternal_starlight: 'Eternal Starlight',
  forbidden_arcanus: 'Forbidden & Arcanus', immersiveengineering: 'Immersive Engineering',
  industrialforegoing: 'Industrial Foregoing', irons_spellbooks: "Iron's Spells 'n Spellbooks",
  justdirethings: 'Just Dire Things', mahou_tsukai: 'Mahou Tsukai',
  mekanism: 'Mekanism', modern_industrialization: 'Modern Industrialization',
  mysticalagriculture: 'Mystical Agriculture', occultism: 'Occultism',
  pneumaticcraft: 'PneumaticCraft', powah: 'Powah',
  productivebees: 'Productive Bees', productivetrees: 'Productive Trees',
  refinedstorage: 'Refined Storage', relics: 'Relics',
  tconstruct: "Tinkers' Construct", twilightforest: 'Twilight Forest',
  undergarden: 'The Undergarden', xycraftworld: 'XyCraft',
  railcraft: 'Railcraft', naturesaura: "Nature's Aura",
  apotheosis: 'Apotheosis', silentgear: 'Silent Gear',
  allthemodium: 'Allthemodium', iceandfire: 'Ice & Fire',
  artifacts: 'Artifacts', integratedynamics: 'Integrated Dynamics',
  oritech: 'Oritech', pylons: 'Pylons',
};

const SKIP_NS = new Set(['minecraft', 'ftbfiltersystem', 'ftbquests', 'forge', 'neoforge', 'c']);

function buildModIndex() {
  if (MOD_INDEX) return MOD_INDEX;
  MOD_INDEX = {};

  for (const ch of DATA.chapters) {
    for (const q of ch.quests) {
      const nsItems = {};  // ns â†’ first item id
      for (const t of (q.tasks || [])) {
        for (const field of ['item', 'entity']) {
          if (!t[field]) continue;
          const ns = t[field].split(':')[0];
          if (SKIP_NS.has(ns)) continue;
          if (!nsItems[ns]) nsItems[ns] = t[field];
        }
      }
      for (const [ns, itemId] of Object.entries(nsItems)) {
        if (!MOD_INDEX[ns]) {
          MOD_INDEX[ns] = {
            ns,
            name: MOD_NAMES[ns] || ns.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
            quests: [],
            itemCounts: {},
            topItem: null,
          };
        }
        MOD_INDEX[ns].quests.push({ q, chapter: ch });
        MOD_INDEX[ns].itemCounts[itemId] = (MOD_INDEX[ns].itemCounts[itemId] || 0) + 1;
      }
    }
  }

  // Najdi nejÄastÄ›jÅ¡Ã­ item jako ikonu modu
  for (const mod of Object.values(MOD_INDEX)) {
    mod.topItem = Object.entries(mod.itemCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || null;
    delete mod.itemCounts;
  }

  return MOD_INDEX;
}

// â”€â”€â”€ SIDEBAR TABS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let sidebarTab = 'chapters';

function switchSidebarTab(tab) {
  sidebarTab = tab;
  document.getElementById('stabChapters').classList.toggle('active', tab === 'chapters');
  document.getElementById('stabMods').classList.toggle('active', tab === 'mods');
  if (tab === 'chapters') {
    buildSidebar();
    // Pokud byl zobrazenÃ½ mod view, vraÅ¥ mapu
    showMapView();
  } else {
    buildModSidebar();
  }
}

function buildModSidebar() {
  const el = document.getElementById('sidebarInner');
  const index = buildModIndex();
  const sorted = Object.values(index).sort((a, b) => b.quests.length - a.quests.length);

  let html = '';
  for (const mod of sorted) {
    const icon = mod.topItem ? itemIcon(mod.topItem, 'ğŸ“¦', 18) : '<span style="width:18px;display:inline-block"></span>';
    const chapters = [...new Set(mod.quests.map(e => stripMc(e.chapter.title)))];
    const chapStr = chapters.slice(0, 2).join(', ') + (chapters.length > 2 ? ` +${chapters.length - 2}` : '');
    html += `<div class="mod-card" data-ns="${escHtml(mod.ns)}" onclick="selectMod('${escHtml(mod.ns)}')">
      ${icon}
      <div class="mod-card-info">
        <div class="mod-card-name">${escHtml(mod.name)}</div>
        <div class="mod-card-sub">${escHtml(chapStr)}</div>
      </div>
      <span class="mod-card-count">${mod.quests.length}</span>
    </div>`;
  }
  el.innerHTML = html;
}

// â”€â”€â”€ MOD DETAIL VIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let activeModNs = null;

function selectMod(ns) {
  activeModNs = ns;
  const mod = buildModIndex()[ns];
  if (!mod) return;

  // ZvÃ½razni aktivnÃ­ mod v sidebaru
  document.querySelectorAll('.mod-card').forEach(c => c.classList.toggle('active', c.dataset.ns === ns));

  // Seskup questy podle kapitoly (zachovej poÅ™adÃ­ kapitol)
  const byChapter = new Map();
  for (const { q, chapter } of mod.quests) {
    const cid = chapter.id;
    if (!byChapter.has(cid)) byChapter.set(cid, { chapter, quests: [] });
    byChapter.get(cid).quests.push(q);
  }

  const icon = mod.topItem ? itemIcon(mod.topItem, 'ğŸ“¦', 32) : '';
  let html = `
    <div class="mod-view-header">
      ${icon}
      <div>
        <div class="mod-view-title">${escHtml(mod.name)}</div>
        <div class="mod-view-meta">${mod.quests.length} quests Â· ${byChapter.size} chapter${byChapter.size !== 1 ? 's' : ''}</div>
      </div>
    </div>`;

  for (const { chapter, quests } of byChapter.values()) {
    html += `<div class="mod-chapter-section">
      <div class="mod-chapter-title">${escHtml(stripMc(chapter.title))}</div>
      <div class="mod-quest-list">`;
    for (const q of quests) {
      const qicon = itemIcon(getQuestIconId(q)?.id || '', '', 18);
      html += `<div class="mod-quest-item" onclick="openModQuest('${escHtml(chapter.id)}','${escHtml(q.id)}')">
        ${qicon}
        <span>${escHtml(stripMc(q.title || ''))}</span>
      </div>`;
    }
    html += `</div></div>`;
  }

  const modView = document.getElementById('modView');
  modView.innerHTML = html;
  modView.style.display = 'flex';
  modView.style.flexDirection = 'column';

  // Skryj mapu
  document.getElementById('mapCanvas').style.display = 'none';
  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('mapControls')?.style && (document.querySelector('.map-controls').style.display = 'none');
}

function openModQuest(chapterId, questId) {
  // PÅ™epni na chapter tab, vyber kapitolu a otevÅ™i quest popup
  switchSidebarTab('chapters');
  selectChapter(chapterId);
  // PoÄkej na vykreslenÃ­ a otevÅ™i popup
  setTimeout(() => {
    const chapter = DATA.chapters.find(c => c.id === chapterId);
    const q = chapter?.quests.find(q => q.id === questId);
    if (q) {
      selectedQuestId = questId;
      const area = document.getElementById('mapArea');
      openPopup(q, area.clientWidth / 2, area.clientHeight / 2);
      requestDraw();
    }
  }, 100);
}

function showMapView() {
  document.getElementById('modView').style.display = 'none';
  document.getElementById('mapCanvas').style.display = '';
  document.querySelector('.map-controls').style.display = '';
  if (activeChapter) {
    document.getElementById('emptyState').style.display = 'none';
  } else {
    document.getElementById('emptyState').style.display = '';
  }
  activeModNs = null;
  document.querySelectorAll('.mod-card').forEach(c => c.classList.remove('active'));
}

function buildSidebar() {
  const el = document.getElementById('sidebarInner');
  // Group chapters by group_title
  const groups = {};
  for (const ch of DATA.chapters) {
    const g = ch.group_title || 'Other';
    if (!groups[g]) groups[g] = [];
    groups[g].push(ch);
  }
  // Sort groups, put Main Questline first
  const groupOrder = ['Main Questline', ...Object.keys(groups).filter(g => g !== 'Main Questline' && g !== 'Other').sort(), 'Other'];

  let html = '';
  for (const g of groupOrder) {
    if (!groups[g]) continue;
    html += `<div class="group-header">${escHtml(g)}</div>`;
    for (const ch of groups[g]) {
      const title = stripMc(ch.title);
      const iconHtml = ch.icon ? itemIcon(ch.icon, '', 16) : '<span style="width:16px;flex-shrink:0;display:inline-block"></span>';
      html += `<button class="chapter-btn" data-id="${escHtml(ch.id)}" onclick="selectChapter('${escHtml(ch.id)}')">
        ${iconHtml}
        <span class="ch-name">${escHtml(title)}</span>
        <span class="ch-count">${ch.quests.length}</span>
      </button>`;
    }
  }
  el.innerHTML = html;
}

// â”€â”€â”€ SELECT CHAPTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function selectChapter(id) {
  activeChapter = DATA.chapters.find(c => c.id === id);
  if (!activeChapter) return;
  selectedQuestId = null;
  closePopup();

  // Update sidebar active state
  document.querySelectorAll('.chapter-btn').forEach(b => b.classList.toggle('active', b.dataset.id === id));
  document.getElementById('chapterTitle').textContent = stripMc(activeChapter.title);
  document.getElementById('emptyState').style.display = 'none';

  fitChapter();
  requestDraw();
  hideSearch();

  // DEBUG â€” odstraÅˆ po ovÄ›Å™enÃ­
  console.log('Chapter images:', activeChapter.images?.length, activeChapter.images?.[0]);
  if (activeChapter.images?.length) {
    const ref = activeChapter.images[0].image;
    console.log('resolveImageUrl:', resolveImageUrl(ref));
    console.log('FILES_MAP key exists:', FILES_MAP ? (ref in FILES_MAP) : 'FILES_MAP null');
    console.log('imageCache has:', imageCache.has(ref), imageCache.get(ref));
  }

  // ZavÅ™i sidebar na mobilu
  document.getElementById('sidebar').classList.remove('mobile-open');
  document.getElementById('sidebarBackdrop').classList.remove('open');
}

// â”€â”€â”€ MAP: FIT TO CHAPTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fitChapter() {
  if (!activeChapter || !activeChapter.quests.length) return;
  const qs = activeChapter.quests;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const q of qs) {
    minX = Math.min(minX, q.x); maxX = Math.max(maxX, q.x);
    minY = Math.min(minY, q.y); maxY = Math.max(maxY, q.y);
  }
  const W = canvas.width, H = canvas.height;
  const rangeX = (maxX - minX) || 1;
  const rangeY = (maxY - minY) || 1;
  const pad = 3;
  vpScale = Math.min(W / (rangeX + pad), H / (rangeY + pad), MAX_SCALE);
  vpScale = Math.max(vpScale, MIN_SCALE);
  vpX = W / 2 - ((minX + maxX) / 2) * vpScale;
  vpY = H / 2 - ((minY + maxY) / 2) * vpScale;
}

// â”€â”€â”€ CANVAS DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resizeCanvas() {
  const area = document.getElementById('mapArea');
  canvas.width = area.clientWidth;
  canvas.height = area.clientHeight;
}

function worldToScreen(wx, wy) {
  return [wx * vpScale + vpX, wy * vpScale + vpY];
}

function screenToWorld(sx, sy) {
  return [(sx - vpX) / vpScale, (sy - vpY) / vpScale];
}

// Build dependency lookup for current chapter
function buildDepMap(chapter) {
  const map = {};
  for (const q of chapter.quests) {
    if (q.deps) {
      for (const dep of q.deps) {
        if (!map[dep]) map[dep] = [];
        map[dep].push(q.id);
      }
    }
  }
  return map;
}

function draw() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Aktualizuj Äas animace
  const now = performance.now();
  animTime += (now - lastFrameTime) / 1000;
  lastFrameTime = now;

  if (!activeChapter) return;

  const quests = activeChapter.quests;
  const questById = {};
  for (const q of quests) questById[q.id] = q;

  // Zkontroluj jestli jsou v kapitole animovanÃ© questy â€” pokud ano, naplÃ¡nuj dalÅ¡Ã­ frame
  const hasAnimated = quests.some(q =>
    q.tasks?.some(t => t.item === 'ftbfiltersystem:smart_filter' && t.filter_items?.length > 1)
  );
  if (hasAnimated) {
    setTimeout(() => requestDraw(), 1000);
  }

  // â”€â”€ DekorativnÃ­ obrÃ¡zky (za questy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  drawChapterImages(ctx, activeChapter);

  // â”€â”€ Draw dependency lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const selectedQ = selectedQuestId ? questById[selectedQuestId] : null;
  const hoveredQ  = hoveredQuestId  ? questById[hoveredQuestId]  : null;
  const focusQ    = selectedQ || hoveredQ;

  // Sety pro zvÃ½raznÄ›nÃ© uzly
  const highlightDeps = new Set();  // pÅ™edchÅ¯dci focusu
  const highlightNext = new Set();  // nÃ¡slednÃ­ci focusu
  if (focusQ) {
    for (const d of (focusQ.deps || [])) highlightDeps.add(d);
    for (const q of quests) {
      if (q.deps && q.deps.includes(focusQ.id)) highlightNext.add(q.id);
    }
  }

  // 1. PozadÃ­ linek â€” dle depsMode
  if (depsMode === 'all' || (depsMode === 'hover' && !focusQ)) {
    ctx.save();
    ctx.globalAlpha = depsMode === 'all' && focusQ ? 0.06 : 0.18;
    ctx.strokeStyle = '#7868a0';
    ctx.lineWidth = 1;
    for (const q of quests) {
      if (!q.deps) continue;
      const [sx, sy] = worldToScreen(q.x, q.y);
      for (const depId of q.deps) {
        const dep = questById[depId];
        if (!dep) continue;
        const [dx, dy] = worldToScreen(dep.x, dep.y);
        ctx.beginPath(); ctx.moveTo(dx, dy); ctx.lineTo(sx, sy); ctx.stroke();
      }
    }
    ctx.restore();
  }

  // 2. ZvÃ½raznÄ›nÃ© linky pro focus (vÅ¾dy, pokud je nÄ›co focusovanÃ©)
  if (focusQ) {
    const [fx, fy] = worldToScreen(focusQ.x, focusQ.y);

    // PÅ™edchÅ¯dci â†’ focus (modrÃ©)
    if (focusQ.deps && focusQ.deps.length) {
      ctx.save();
      ctx.strokeStyle = '#4a80e8';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.85;
      for (const depId of focusQ.deps) {
        const dep = questById[depId];
        if (!dep) continue;
        const [dx, dy] = worldToScreen(dep.x, dep.y);
        // Å ipka pomocÃ­ offsetu
        drawArrow(ctx, dx, dy, fx, fy, '#4a80e8');
      }
      ctx.restore();
    }

    // Focus â†’ nÃ¡slednÃ­ci (zlatÃ©)
    if (highlightNext.size) {
      ctx.save();
      ctx.strokeStyle = '#d4a843';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.85;
      for (const nid of highlightNext) {
        const nq = questById[nid];
        if (!nq) continue;
        const [nx, ny] = worldToScreen(nq.x, nq.y);
        drawArrow(ctx, fx, fy, nx, ny, '#d4a843');
      }
      ctx.restore();
    }
  }

  // â”€â”€ Draw quest nodes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const r = vpScale * 0.38;  // base radius
  const font = Math.max(9, Math.min(13, vpScale * 0.2));

  for (const q of quests) {
    if (q.invisible) continue;
    const [sx, sy] = worldToScreen(q.x, q.y);
    const qr = r * (q.size || 1.0);

    // Skip off-screen
    if (sx + qr < 0 || sx - qr > W || sy + qr < 0 || sy - qr > H) continue;

    const isSelected = q.id === selectedQuestId;
    const isHovered = q.id === hoveredQuestId;
    const hasDesc = q.desc && q.desc.length > 0;

    // Colors
    let fillColor, strokeColor;
    if (isSelected) {
      fillColor = 'rgba(212,168,67,0.25)';
      strokeColor = '#d4a843';
    } else if (isHovered) {
      fillColor = 'rgba(255,255,255,0.08)';
      strokeColor = '#a89870';
    } else if (hasDesc) {
      fillColor = 'rgba(74,100,140,0.2)';
      strokeColor = '#4a6490';
    } else {
      fillColor = 'rgba(30,36,50,0.8)';
      strokeColor = '#313b52';
    }

    ctx.save();
    ctx.translate(sx, sy);

    // Draw shape
    drawShape(ctx, q.shape || 'rsquare', qr, fillColor, strokeColor, isSelected ? 2 : 1);

    // Ikona (pokud je dost velkÃ¡)
    if (qr >= 10) {
      const iconSize = qr * 1.3;
      drawQuestIcon(ctx, q, iconSize);
    }

    // Label (only if large enough a nenÃ­ ikona)
    if (vpScale >= 35 && q.title_plain) {
      const label = q.title_plain.length > 18 ? q.title_plain.slice(0, 16) + 'â€¦' : q.title_plain;
      ctx.font = `${font}px "Source Serif 4", serif`;
      ctx.fillStyle = isSelected ? '#e8c060' : '#9a9080';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, 0, qr + font * 0.8);
    }

    // Glow for selected
    if (isSelected) {
      ctx.shadowBlur = 16;
      ctx.shadowColor = '#d4a843';
      drawShape(ctx, q.shape || 'rsquare', qr, 'transparent', '#d4a843', 1.5);
      ctx.shadowBlur = 0;
    }

    ctx.restore();
  }
}

function drawShape(ctx, shape, r, fill, stroke, lineW) {
  ctx.beginPath();
  switch (shape) {
    case 'circle':
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      break;

    case 'diamond': {
      const d = r * 1.1;
      ctx.moveTo(0, -d); ctx.lineTo(d, 0); ctx.lineTo(0, d); ctx.lineTo(-d, 0);
      ctx.closePath();
      break;
    }

    case 'hexagon':
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i - Math.PI / 6;
        i === 0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath();
      break;

    case 'octagon':
      for (let i = 0; i < 8; i++) {
        const a = (Math.PI / 4) * i - Math.PI / 8;
        i === 0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath();
      break;

    case 'pentagon':
      for (let i = 0; i < 5; i++) {
        const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
        i === 0 ? ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r) : ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      }
      ctx.closePath();
      break;

    case 'heart': {
      // Srdce pomocÃ­ bÃ©zierovÃ½ch kÅ™ivek
      const s = r * 0.75;
      ctx.moveTo(0, s);
      ctx.bezierCurveTo(-s*2, -s*0.3, -s*2.2, -s*1.8, 0, -s*0.8);
      ctx.bezierCurveTo( s*2.2, -s*1.8,  s*2,  -s*0.3, 0, s);
      ctx.closePath();
      break;
    }

    case 'gear': {
      const teeth = 8;
      for (let i = 0; i < teeth * 2; i++) {
        const a = (Math.PI / teeth) * i;
        const rr = i % 2 === 0 ? r : r * 0.78;
        i === 0 ? ctx.moveTo(Math.cos(a)*rr, Math.sin(a)*rr) : ctx.lineTo(Math.cos(a)*rr, Math.sin(a)*rr);
      }
      ctx.closePath();
      break;
    }

    case 'none':
      // Å½Ã¡dnÃ½ tvar â€” jen teÄka pro orientaci
      ctx.arc(0, 0, r * 0.25, 0, Math.PI * 2);
      break;

    case 'square': {
      const s = r * 0.85;
      ctx.rect(-s, -s, s*2, s*2);
      break;
    }

    case 'rsquare':
    default: {
      const s = r * 0.85;
      const cr = s * 0.2;
      ctx.moveTo(-s+cr, -s);
      ctx.lineTo(s-cr, -s); ctx.arcTo(s, -s, s, -s+cr, cr);
      ctx.lineTo(s, s-cr);  ctx.arcTo(s, s, s-cr, s, cr);
      ctx.lineTo(-s+cr, s); ctx.arcTo(-s, s, -s, s-cr, cr);
      ctx.lineTo(-s, -s+cr);ctx.arcTo(-s, -s, -s+cr, -s, cr);
      ctx.closePath();
      break;
    }
  }
  ctx.fillStyle = fill;
  ctx.fill();
  if (shape !== 'none') {
    ctx.strokeStyle = stroke;
    ctx.lineWidth = lineW;
    ctx.stroke();
  }
}

let drawPending = false;
function requestDraw() {
  if (!drawPending) {
    drawPending = true;
    requestAnimationFrame(() => { draw(); drawPending = false; });
  }
}

// NakreslÃ­ linku se Å¡ipkou na konci
function drawArrow(ctx, x1, y1, x2, y2, color) {
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.sqrt(dx*dx + dy*dy);
  if (len < 4) return;
  const ux = dx/len, uy = dy/len;
  const arrowLen = Math.min(10, len * 0.3);
  const arrowW = 4;
  // ZkraÅ¥ linku o polomÄ›r cÃ­lovÃ©ho uzlu (cca 6px) aby nevlÃ©zala do tvaru
  const endX = x2 - ux * 6, endY = y2 - uy * 6;

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(endX, endY);
  ctx.stroke();

  // Å ipka
  ctx.beginPath();
  ctx.moveTo(endX, endY);
  ctx.lineTo(endX - ux*arrowLen + uy*arrowW, endY - uy*arrowLen - ux*arrowW);
  ctx.lineTo(endX - ux*arrowLen - uy*arrowW, endY - uy*arrowLen + ux*arrowW);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
}

// â”€â”€â”€ MOUSE / TOUCH INTERACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getQuestAtScreen(sx, sy) {
  if (!activeChapter) return null;
  const r = vpScale * 0.38;
  for (let i = activeChapter.quests.length - 1; i >= 0; i--) {
    const q = activeChapter.quests[i];
    if (q.invisible) continue;
    const [qx, qy] = worldToScreen(q.x, q.y);
    const qr = r * (q.size || 1.0) * 1.1;
    const dx = sx - qx, dy = sy - qy;
    if (dx * dx + dy * dy < qr * qr) return q;
  }
  return null;
}

canvas.addEventListener('mousedown', e => {
  const q = getQuestAtScreen(e.offsetX, e.offsetY);
  if (q) {
    selectQuest(q, e.offsetX, e.offsetY);
    return;
  }
  isDragging = true;
  dragStartX = e.clientX; dragStartY = e.clientY;
  vpXStart = vpX; vpYStart = vpY;
  canvas.classList.add('grabbing');
});

canvas.addEventListener('mousemove', e => {
  if (isDragging) {
    vpX = vpXStart + (e.clientX - dragStartX);
    vpY = vpYStart + (e.clientY - dragStartY);
    requestDraw();
    return;
  }
  const q = getQuestAtScreen(e.offsetX, e.offsetY);
  const newId = q ? q.id : null;
  if (newId !== hoveredQuestId) {
    hoveredQuestId = newId;
    canvas.classList.toggle('hovering', !!newId);
    requestDraw();
  }
  if (q) {
    showTooltip(e.clientX, e.clientY, q);
  } else {
    hideTooltip();
  }
});

canvas.addEventListener('mouseup', () => { isDragging = false; canvas.classList.remove('grabbing'); });
canvas.addEventListener('mouseleave', () => { isDragging = false; canvas.classList.remove('grabbing'); hideTooltip(); });

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.12 : 0.89;
  const mx = e.offsetX, my = e.offsetY;
  const [wx, wy] = screenToWorld(mx, my);
  vpScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, vpScale * factor));
  vpX = mx - wx * vpScale;
  vpY = my - wy * vpScale;
  requestDraw();
}, { passive: false });

// Touch
let lastTouchDist = 0, lastTouchMidX = 0, lastTouchMidY = 0;
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 2) {
    const t0 = e.touches[0], t1 = e.touches[1];
    lastTouchDist = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
    lastTouchMidX = (t0.clientX + t1.clientX) / 2;
    lastTouchMidY = (t0.clientY + t1.clientY) / 2;
  } else if (e.touches.length === 1) {
    isDragging = true;
    dragStartX = e.touches[0].clientX; dragStartY = e.touches[0].clientY;
    vpXStart = vpX; vpYStart = vpY;
  }
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const t0 = e.touches[0], t1 = e.touches[1];
    const dist = Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
    const midX = (t0.clientX + t1.clientX) / 2;
    const midY = (t0.clientY + t1.clientY) / 2;
    const rect = canvas.getBoundingClientRect();
    const [wx, wy] = screenToWorld(midX - rect.left, midY - rect.top);
    vpScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, vpScale * (dist / lastTouchDist)));
    vpX = (midX - rect.left) - wx * vpScale;
    vpY = (midY - rect.top) - wy * vpScale;
    lastTouchDist = dist;
    requestDraw();
  } else if (e.touches.length === 1 && isDragging) {
    vpX = vpXStart + (e.touches[0].clientX - dragStartX);
    vpY = vpYStart + (e.touches[0].clientY - dragStartY);
    requestDraw();
  }
}, { passive: false });
canvas.addEventListener('touchend', e => {
  if (e.touches.length === 0) {
    if (!isDragging) return;
    isDragging = false;
    // tap: find quest
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const sx = touch.clientX - rect.left;
    const sy = touch.clientY - rect.top;
    const q = getQuestAtScreen(sx, sy);
    if (q) selectQuest(q, sx, sy);
  }
});

// â”€â”€â”€ ZOOM CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btnZoomIn').onclick = () => {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const [wx, wy] = screenToWorld(cx, cy);
  vpScale = Math.min(MAX_SCALE, vpScale * 1.25);
  vpX = cx - wx * vpScale; vpY = cy - wy * vpScale;
  requestDraw();
};
document.getElementById('btnZoomOut').onclick = () => {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const [wx, wy] = screenToWorld(cx, cy);
  vpScale = Math.max(MIN_SCALE, vpScale * 0.8);
  vpX = cx - wx * vpScale; vpY = cy - wy * vpScale;
  requestDraw();
};
document.getElementById('btnFit').onclick = () => { fitChapter(); requestDraw(); };

// Deps toggle: hover â†’ all â†’ none â†’ hover
const DEP_MODES = ['hover', 'all', 'none'];
const DEP_LABELS = { hover: 'DEP', all: 'DEPâ—', none: 'DEPâ—‹' };
const DEP_TITLES = { hover: 'Deps: on hover only', all: 'Deps: always visible', none: 'Deps: hidden' };
const btnDeps = document.getElementById('btnDeps');
btnDeps.onclick = () => {
  const idx = DEP_MODES.indexOf(depsMode);
  depsMode = DEP_MODES[(idx + 1) % DEP_MODES.length];
  btnDeps.textContent = DEP_LABELS[depsMode];
  btnDeps.title = DEP_TITLES[depsMode];
  btnDeps.style.color = depsMode === 'all' ? 'var(--gold)' : depsMode === 'none' ? 'var(--text-dim)' : '';
  requestDraw();
};

// Sidebar toggle (mobile)
const sidebar = document.getElementById('sidebar');
const sidebarBackdrop = document.getElementById('sidebarBackdrop');
document.getElementById('sidebarToggle').onclick = () => {
  sidebar.classList.add('mobile-open');
  sidebarBackdrop.classList.add('open');
};
sidebarBackdrop.onclick = () => {
  sidebar.classList.remove('mobile-open');
  sidebarBackdrop.classList.remove('open');
};

// â”€â”€â”€ QUEST POPUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const popup        = document.getElementById('questPopup');
const popupBackdrop = document.getElementById('popupBackdrop');

function selectQuest(q, screenX, screenY) {
  selectedQuestId = q.id;
  requestDraw();
  openPopup(q, screenX, screenY);
}

function openPopup(q, screenX, screenY) {
  const header = document.getElementById('popupHeader');
  const body   = document.getElementById('popupBody');

  // Header
  const wikiUrl = getWikiUrl(q);
  const wikiBtn = wikiUrl
    ? `<a class="popup-wiki" href="${wikiUrl}" target="_blank" title="Open wiki">ğŸ“–</a>`
    : '';

  header.innerHTML = `
    <button class="popup-close" id="popupClose" onclick="closePopup()">âœ•</button>
    <div class="popup-title">${mcToHtml(q.title)}</div>
    ${q.subtitle ? `<div class="popup-subtitle">${mcToHtml(q.subtitle)}</div>` : ''}
    ${wikiBtn}
  `;

  // Body
  let html = '';

  if (q.desc && q.desc.length > 0) {
    const combined = q.desc.join('\n');
    html += `<div class="section-label">Description</div>`;
    html += `<div class="quest-desc">${mcToHtml(combined).replace(/\n/g, '<br>')}</div>`;
  } else {
    html += `<div class="no-desc">No description available.</div>`;
  }

  if (q.tasks && q.tasks.length > 0) {
    html += `<div class="popup-divider"></div><div class="section-label">Tasks</div><div class="task-list">`;
    for (const t of q.tasks) {
      const emoji = taskIcon(t.type);
      let name = '', iconHtml = '';

      // â”€â”€ Smart filter â€” rozviÅˆ obsah filtru â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (t.item === 'ftbfiltersystem:smart_filter' && t.filter_items?.length) {
        const cnt = t.count && t.count > 1 ? `<span class="t-count">Ã—${t.count}</span>` : '';
        const filterIcons = t.filter_items.map(id => {
          const iname = id.split(':').pop().replace(/_/g, ' ');
          return `<span class="filter-icon" title="${escHtml(id)}">${itemIcon(id, '?', 18)}</span>`;
        }).join('');
        html += `
          <div class="task-item-wrap">
            <div class="task-item">
              ${itemIcon('ftbfiltersystem:smart_filter', 'ğŸ”', 20)}
              <span class="t-name">Any of ${t.filter_items.length} items</span>
              ${cnt}
            </div>
            <div class="filter-items-grid">${filterIcons}</div>
          </div>`;
        continue;
      }

      if (t.item) {
        name = t.item.split(':').pop().replace(/_/g, ' ');
        iconHtml = itemIcon(t.item, emoji);
      } else if (t.entity) {
        name = 'Kill: ' + t.entity.split(':').pop().replace(/_/g, ' ');
        iconHtml = itemIcon(t.entity, emoji);
      } else if (t.advancement) {
        name = t.advancement.split('/').pop().replace(/_/g, ' ');
        iconHtml = `<span>${emoji}</span>`;
      } else if (t.biome) {
        name = t.biome.split(':').pop().replace(/_/g, ' ');
        iconHtml = `<span>${emoji}</span>`;
      } else if (t.dimension) {
        name = t.dimension.split(':').pop().replace(/_/g, ' ');
        iconHtml = `<span>${emoji}</span>`;
      } else if (t.structure) {
        name = t.structure.split(':').pop().replace(/_/g, ' ');
        iconHtml = `<span>${emoji}</span>`;
      } else {
        name = t.type; iconHtml = `<span>${emoji}</span>`;
      }
      const cnt = t.count && t.count > 1 ? `<span class="t-count">Ã—${t.count}</span>` : '';
      const stats = t.item ? renderItemStats(t.item) : '';
      const taskRow = `<div class="task-item">${iconHtml}<span class="t-name">${escHtml(name)}</span>${cnt}</div>`;
      html += stats
        ? `<div class="task-item-wrap">${taskRow}${stats}</div>`
        : taskRow;
    }
    html += `</div>`;
  }

  if (q.rewards && q.rewards.length > 0) {
    html += `<div class="popup-divider"></div><div class="section-label">Rewards</div>`;
    html += `<div class="rewards-list">`;
    for (const r of q.rewards) {
      if (r.type === 'item' && r.item) {
        const name = r.item.split(':').pop().replace(/_/g, ' ');
        const cnt  = r.count && r.count > 1 ? `<span class="t-count">Ã—${r.count}</span>` : '';
        html += `<div class="reward-item">${itemIcon(r.item, 'ğŸ“¦', 20)}<span class="r-name">${escHtml(name)}</span>${cnt}</div>`;
      } else if (r.type === 'xp') {
        html += `<div class="reward-item"><span class="reward-xp-icon">âœ¨</span><span class="r-name">${r.xp} XP</span></div>`;
      } else if (r.type === 'xp_levels') {
        html += `<div class="reward-item"><span class="reward-xp-icon">â­</span><span class="r-name">${r.xp_levels} level${r.xp_levels > 1 ? 's' : ''}</span></div>`;
      } else if (r.type === 'random') {
        html += `<div class="reward-item"><span class="reward-xp-icon">ğŸ²</span><span class="r-name">Random reward</span></div>`;
      } else if (r.type === 'choice') {
        html += `<div class="reward-item"><span class="reward-xp-icon">ğŸ</span><span class="r-name">Choice reward</span></div>`;
      } else if (r.type === 'loot') {
        html += `<div class="reward-item"><span class="reward-xp-icon">ğŸ“¦</span><span class="r-name">Loot reward</span></div>`;
      } else if (r.type === 'blood') {
        html += `<div class="reward-item"><span class="reward-xp-icon">ğŸ©¸</span><span class="r-name">${r.blood} Blood</span></div>`;
      }
    }
    html += `</div>`;
  }

  body.innerHTML = html;

  // PozicovÃ¡nÃ­ â€” otevÅ™i blÃ­zko kliknutÃ©ho questu, ale ne mimo obrazovku
  popup.style.display = 'flex';  // musÃ­ bÃ½t viditelnÃ½ pro mÄ›Å™enÃ­
  popup.classList.add('open');
  popupBackdrop.classList.add('open');

  const area  = document.getElementById('mapArea');
  const areaW = area.clientWidth;
  const areaH = area.clientHeight;
  const popW  = popup.offsetWidth;
  const popH  = popup.offsetHeight;
  const margin = 16;
  const offset = 24;  // offset od kliknutÃ©ho bodu

  let left = (screenX || areaW / 2) + offset;
  let top  = (screenY || areaH / 2) - popH / 2;

  // NepÅ™etÃ©kej pÅ™es pravÃ½ okraj
  if (left + popW + margin > areaW) left = (screenX || areaW/2) - popW - offset;
  // NepÅ™etÃ©kej pÅ™es spodnÃ­/hornÃ­ okraj
  top = Math.max(margin, Math.min(top, areaH - popH - margin));
  left = Math.max(margin, left);

  popup.style.left = left + 'px';
  popup.style.top  = top  + 'px';
}

function closePopup() {
  popup.classList.remove('open');
  popup.style.display = 'none';
  popupBackdrop.classList.remove('open');
  selectedQuestId = null;
  requestDraw();
}

popupBackdrop.addEventListener('click', closePopup);
document.addEventListener('keydown', e => { if (e.key === 'Escape') closePopup(); });

function taskIcon(type) {
  const map = {
    item: 'ğŸ“¦', kill: 'âš”ï¸', checkmark: 'âœ…', advancement: 'ğŸ†',
    biome: 'ğŸŒ', dimension: 'ğŸŒ', structure: 'ğŸ›ï¸', observation: 'ğŸ‘ï¸',
    blood: 'ğŸ©¸', fluid: 'ğŸ’§', energy: 'âš¡',
  };
  return map[type] || 'ğŸ“Œ';
}

// â”€â”€â”€ TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const tooltip = document.getElementById('tooltip');
function showTooltip(mx, my, q) {
  tooltip.innerHTML = `<div class="tt-title">${escHtml(stripMc(q.title))}</div>${q.subtitle ? `<div class="tt-sub">${escHtml(stripMc(q.subtitle))}</div>` : ''}`;
  tooltip.style.display = 'block';
  const tw = tooltip.offsetWidth, th = tooltip.offsetHeight;
  tooltip.style.left = (mx + 14 + tw > window.innerWidth ? mx - tw - 8 : mx + 14) + 'px';
  tooltip.style.top = (my + 20 + th > window.innerHeight ? my - th - 6 : my + 10) + 'px';
}
function hideTooltip() { tooltip.style.display = 'none'; }

// â”€â”€â”€ SEARCH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let searchTimer;
document.getElementById('searchInput').addEventListener('input', e => {
  clearTimeout(searchTimer);
  const q = e.target.value.trim();
  if (!q) { hideSearch(); return; }
  searchTimer = setTimeout(() => runSearch(q), 180);
});
document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Escape') { hideSearch(); e.target.blur(); }
});

function runSearch(query) {
  if (!DATA) return;
  const ql = query.toLowerCase();
  const overlay = document.getElementById('searchOverlay');
  overlay.classList.add('visible');

  const results = [];
  for (const ch of DATA.chapters) {
    const chMatches = [];
    for (const q of ch.quests) {
      const titleMatch = q.title_plain.toLowerCase().includes(ql);
      const descMatch = q.desc && q.desc.some(d => stripMc(d).toLowerCase().includes(ql));
      if (titleMatch || descMatch) {
        chMatches.push({ q, titleMatch, descMatch });
      }
    }
    if (chMatches.length) results.push({ ch, matches: chMatches });
  }

  if (!results.length) {
    overlay.innerHTML = `<div class="search-results-title">Search: "${escHtml(query)}"</div><div class="no-results">No quests found.</div>`;
    return;
  }

  let html = `<div class="search-results-title">Found in ${results.reduce((s,r) => s+r.matches.length,0)} quests across ${results.length} chapters</div>`;
  for (const { ch, matches } of results.slice(0, 20)) {
    html += `<div class="search-group-title">${escHtml(stripMc(ch.title))}</div>`;
    for (const { q, descMatch } of matches.slice(0, 8)) {
      const titleHl = highlight(q.title_plain, ql);
      let descSnippet = '';
      if (descMatch && q.desc) {
        const line = q.desc.find(d => stripMc(d).toLowerCase().includes(ql));
        if (line) descSnippet = highlight(stripMc(line).slice(0, 80) + (line.length > 80 ? 'â€¦' : ''), ql);
      }
      html += `<div class="search-result-item" onclick="jumpToQuest('${ch.id}','${q.id}')">
        <div class="sri-title">${titleHl}</div>
        ${descSnippet ? `<div class="sri-desc">${descSnippet}</div>` : ''}
      </div>`;
    }
    if (matches.length > 8) html += `<div class="sri-desc" style="padding:4px 12px;opacity:0.5">â€¦and ${matches.length - 8} more</div>`;
  }
  overlay.innerHTML = html;
}

function highlight(text, query) {
  const idx = text.toLowerCase().indexOf(query.toLowerCase());
  if (idx === -1) return escHtml(text);
  return escHtml(text.slice(0, idx)) + '<mark>' + escHtml(text.slice(idx, idx + query.length)) + '</mark>' + escHtml(text.slice(idx + query.length));
}

function hideSearch() {
  document.getElementById('searchOverlay').classList.remove('visible');
  document.getElementById('searchInput').value = '';
}

function jumpToQuest(chapterId, questId) {
  hideSearch();
  selectChapter(chapterId);
  setTimeout(() => {
    const q = activeChapter?.quests.find(q => q.id === questId);
    if (!q) return;
    // Centruj na quest
    const cx = canvas.width / 2, cy = canvas.height / 2;
    vpX = cx - q.x * vpScale;
    vpY = cy - q.y * vpScale;
    selectedQuestId = questId;
    requestDraw();
    openPopup(q, cx + vpScale * 2, cy);
  }, 50);
}

// â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ro = new ResizeObserver(() => {
  resizeCanvas();
  requestDraw();
});
ro.observe(document.getElementById('mapArea'));

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resizeCanvas();
loadData();
</script>
</body>
</html>
